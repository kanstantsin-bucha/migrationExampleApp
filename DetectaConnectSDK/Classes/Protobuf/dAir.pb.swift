// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: dAir.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct D_Req {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sessionID: UInt32 = 0

  public var requestID: UInt32 = 0

  public var message: D_Req.OneOf_Message? = nil

  public var setup: D_Req.Setup {
    get {
      if case .setup(let v)? = message {return v}
      return D_Req.Setup()
    }
    set {message = .setup(newValue)}
  }

  public var info: D_Req.Info {
    get {
      if case .info(let v)? = message {return v}
      return D_Req.Info()
    }
    set {message = .info(newValue)}
  }

  public var state: D_Req.State {
    get {
      if case .state(let v)? = message {return v}
      return D_Req.State()
    }
    set {message = .state(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Message: Equatable {
    case setup(D_Req.Setup)
    case info(D_Req.Info)
    case state(D_Req.State)

  #if !swift(>=4.1)
    public static func ==(lhs: D_Req.OneOf_Message, rhs: D_Req.OneOf_Message) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.setup, .setup): return {
        guard case .setup(let l) = lhs, case .setup(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.info, .info): return {
        guard case .info(let l) = lhs, case .info(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.state, .state): return {
        guard case .state(let l) = lhs, case .state(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct Setup {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var timezone: Int32 = 0

    public var connect: D_Req.Setup.Connect {
      get {return _connect ?? D_Req.Setup.Connect()}
      set {_connect = newValue}
    }
    /// Returns true if `connect` has been explicitly set.
    public var hasConnect: Bool {return self._connect != nil}
    /// Clears the value of `connect`. Subsequent reads from it will return its default value.
    public mutating func clearConnect() {self._connect = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Connect {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var ssid: String = String()

      public var pass: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _connect: D_Req.Setup.Connect? = nil
  }

  public struct Info {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct State {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct D_Resp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sessionID: UInt32 {
    get {return _storage._sessionID}
    set {_uniqueStorage()._sessionID = newValue}
  }

  public var requestID: UInt32 {
    get {return _storage._requestID}
    set {_uniqueStorage()._requestID = newValue}
  }

  public var status: D_Resp.Status {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  public var error: UInt32 {
    get {return _storage._error}
    set {_uniqueStorage()._error = newValue}
  }

  public var message: OneOf_Message? {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  public var setup: D_Resp.Setup {
    get {
      if case .setup(let v)? = _storage._message {return v}
      return D_Resp.Setup()
    }
    set {_uniqueStorage()._message = .setup(newValue)}
  }

  public var info: D_Resp.Info {
    get {
      if case .info(let v)? = _storage._message {return v}
      return D_Resp.Info()
    }
    set {_uniqueStorage()._message = .info(newValue)}
  }

  public var state: D_Resp.State {
    get {
      if case .state(let v)? = _storage._message {return v}
      return D_Resp.State()
    }
    set {_uniqueStorage()._message = .state(newValue)}
  }

  public var context: D_Resp.Context {
    get {
      if case .context(let v)? = _storage._message {return v}
      return D_Resp.Context()
    }
    set {_uniqueStorage()._message = .context(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Message: Equatable {
    case setup(D_Resp.Setup)
    case info(D_Resp.Info)
    case state(D_Resp.State)
    case context(D_Resp.Context)

  #if !swift(>=4.1)
    public static func ==(lhs: D_Resp.OneOf_Message, rhs: D_Resp.OneOf_Message) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.setup, .setup): return {
        guard case .setup(let l) = lhs, case .setup(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.info, .info): return {
        guard case .info(let l) = lhs, case .info(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.state, .state): return {
        guard case .state(let l) = lhs, case .state(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.context, .context): return {
        guard case .context(let l) = lhs, case .context(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case unsupported // = 1
    case timeout // = 2
    case serviceError // = 3
    case generalError // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .unsupported
      case 2: self = .timeout
      case 3: self = .serviceError
      case 4: self = .generalError
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .unsupported: return 1
      case .timeout: return 2
      case .serviceError: return 3
      case .generalError: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct Setup {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var token: String = String()

    public var info: D_Resp.Info {
      get {return _info ?? D_Resp.Info()}
      set {_info = newValue}
    }
    /// Returns true if `info` has been explicitly set.
    public var hasInfo: Bool {return self._info != nil}
    /// Clears the value of `info`. Subsequent reads from it will return its default value.
    public mutating func clearInfo() {self._info = nil}

    public var state: D_Resp.State {
      get {return _state ?? D_Resp.State()}
      set {_state = newValue}
    }
    /// Returns true if `state` has been explicitly set.
    public var hasState: Bool {return self._state != nil}
    /// Clears the value of `state`. Subsequent reads from it will return its default value.
    public mutating func clearState() {self._state = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _info: D_Resp.Info? = nil
    fileprivate var _state: D_Resp.State? = nil
  }

  public struct Info {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var model: String = String()

    public var boardVersion: String = String()

    public var factoryVersion: String = String()

    public var otaVersion: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct State {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var millis: UInt32 = 0

    public var freeHeap: UInt32 = 0

    public var connect: D_Resp.State.Connect {
      get {return _connect ?? D_Resp.State.Connect()}
      set {_connect = newValue}
    }
    /// Returns true if `connect` has been explicitly set.
    public var hasConnect: Bool {return self._connect != nil}
    /// Clears the value of `connect`. Subsequent reads from it will return its default value.
    public mutating func clearConnect() {self._connect = nil}

    public var masks: D_Resp.State.Masks {
      get {return _masks ?? D_Resp.State.Masks()}
      set {_masks = newValue}
    }
    /// Returns true if `masks` has been explicitly set.
    public var hasMasks: Bool {return self._masks != nil}
    /// Clears the value of `masks`. Subsequent reads from it will return its default value.
    public mutating func clearMasks() {self._masks = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Connect {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var ipV4Addres: String = String()

      public var mDnsname: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct Masks {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var persistent: UInt32 = 0

      public var standby: UInt32 = 0

      public var state: UInt32 = 0

      public var alarm: UInt32 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _connect: D_Resp.State.Connect? = nil
    fileprivate var _masks: D_Resp.State.Masks? = nil
  }

  public struct Context {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var millis: UInt32 = 0

    public var busVoltage: Float = 0

    public var coZeroV: Float = 0

    public var coV: Float = 0

    public var coPpm: Float = 0

    public var tempCelsius: Float = 0

    public var pressurePa: Float = 0

    public var humidity: Float = 0

    public var gasResistance: Float = 0

    public var iaq: Float = 0

    public var staticIaq: Float = 0

    public var co2Equivalent: Float = 0

    public var breathVocEquivalent: Float = 0

    public var compGasValue: Float = 0

    public var gasPercentage: Float = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension D_Resp.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [D_Resp.Status] = [
    .ok,
    .unsupported,
    .timeout,
    .serviceError,
    .generalError,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "D"

extension D_Req: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Req"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sessionId"),
    2: .same(proto: "requestId"),
    51: .same(proto: "setup"),
    52: .same(proto: "info"),
    53: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.sessionID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.requestID) }()
      case 51: try {
        var v: D_Req.Setup?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .setup(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .setup(v)}
      }()
      case 52: try {
        var v: D_Req.Info?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .info(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .info(v)}
      }()
      case 53: try {
        var v: D_Req.State?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .state(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .state(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sessionID != 0 {
      try visitor.visitSingularUInt32Field(value: self.sessionID, fieldNumber: 1)
    }
    if self.requestID != 0 {
      try visitor.visitSingularUInt32Field(value: self.requestID, fieldNumber: 2)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.message {
    case .setup?: try {
      guard case .setup(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
    }()
    case .info?: try {
      guard case .info(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
    }()
    case .state?: try {
      guard case .state(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D_Req, rhs: D_Req) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D_Req.Setup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = D_Req.protoMessageName + ".Setup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timezone"),
    2: .same(proto: "connect"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.timezone) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._connect) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timezone != 0 {
      try visitor.visitSingularInt32Field(value: self.timezone, fieldNumber: 1)
    }
    if let v = self._connect {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D_Req.Setup, rhs: D_Req.Setup) -> Bool {
    if lhs.timezone != rhs.timezone {return false}
    if lhs._connect != rhs._connect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D_Req.Setup.Connect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = D_Req.Setup.protoMessageName + ".Connect"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ssid"),
    2: .same(proto: "pass"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ssid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pass) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ssid.isEmpty {
      try visitor.visitSingularStringField(value: self.ssid, fieldNumber: 1)
    }
    if !self.pass.isEmpty {
      try visitor.visitSingularStringField(value: self.pass, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D_Req.Setup.Connect, rhs: D_Req.Setup.Connect) -> Bool {
    if lhs.ssid != rhs.ssid {return false}
    if lhs.pass != rhs.pass {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D_Req.Info: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = D_Req.protoMessageName + ".Info"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D_Req.Info, rhs: D_Req.Info) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D_Req.State: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = D_Req.protoMessageName + ".State"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D_Req.State, rhs: D_Req.State) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D_Resp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Resp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sessionId"),
    2: .same(proto: "requestId"),
    3: .same(proto: "status"),
    4: .same(proto: "error"),
    51: .same(proto: "setup"),
    52: .same(proto: "info"),
    53: .same(proto: "state"),
    54: .same(proto: "context"),
  ]

  fileprivate class _StorageClass {
    var _sessionID: UInt32 = 0
    var _requestID: UInt32 = 0
    var _status: D_Resp.Status = .ok
    var _error: UInt32 = 0
    var _message: D_Resp.OneOf_Message?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _sessionID = source._sessionID
      _requestID = source._requestID
      _status = source._status
      _error = source._error
      _message = source._message
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._sessionID) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._requestID) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._error) }()
        case 51: try {
          var v: D_Resp.Setup?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .setup(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .setup(v)}
        }()
        case 52: try {
          var v: D_Resp.Info?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .info(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .info(v)}
        }()
        case 53: try {
          var v: D_Resp.State?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .state(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .state(v)}
        }()
        case 54: try {
          var v: D_Resp.Context?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .context(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .context(v)}
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._sessionID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._sessionID, fieldNumber: 1)
      }
      if _storage._requestID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._requestID, fieldNumber: 2)
      }
      if _storage._status != .ok {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 3)
      }
      if _storage._error != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._error, fieldNumber: 4)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._message {
      case .setup?: try {
        guard case .setup(let v)? = _storage._message else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
      }()
      case .info?: try {
        guard case .info(let v)? = _storage._message else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
      }()
      case .state?: try {
        guard case .state(let v)? = _storage._message else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
      }()
      case .context?: try {
        guard case .context(let v)? = _storage._message else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 54)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D_Resp, rhs: D_Resp) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sessionID != rhs_storage._sessionID {return false}
        if _storage._requestID != rhs_storage._requestID {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._error != rhs_storage._error {return false}
        if _storage._message != rhs_storage._message {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D_Resp.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "Unsupported"),
    2: .same(proto: "Timeout"),
    3: .same(proto: "ServiceError"),
    4: .same(proto: "GeneralError"),
  ]
}

extension D_Resp.Setup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = D_Resp.protoMessageName + ".Setup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "info"),
    3: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D_Resp.Setup, rhs: D_Resp.Setup) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs._info != rhs._info {return false}
    if lhs._state != rhs._state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D_Resp.Info: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = D_Resp.protoMessageName + ".Info"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "model"),
    2: .same(proto: "boardVersion"),
    3: .same(proto: "factoryVersion"),
    4: .same(proto: "otaVersion"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.model) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.boardVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.factoryVersion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.otaVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.model.isEmpty {
      try visitor.visitSingularStringField(value: self.model, fieldNumber: 1)
    }
    if !self.boardVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.boardVersion, fieldNumber: 2)
    }
    if !self.factoryVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.factoryVersion, fieldNumber: 3)
    }
    if !self.otaVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.otaVersion, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D_Resp.Info, rhs: D_Resp.Info) -> Bool {
    if lhs.model != rhs.model {return false}
    if lhs.boardVersion != rhs.boardVersion {return false}
    if lhs.factoryVersion != rhs.factoryVersion {return false}
    if lhs.otaVersion != rhs.otaVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D_Resp.State: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = D_Resp.protoMessageName + ".State"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "millis"),
    2: .same(proto: "freeHeap"),
    20: .same(proto: "connect"),
    21: .same(proto: "masks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.millis) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.freeHeap) }()
      case 20: try { try decoder.decodeSingularMessageField(value: &self._connect) }()
      case 21: try { try decoder.decodeSingularMessageField(value: &self._masks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.millis != 0 {
      try visitor.visitSingularUInt32Field(value: self.millis, fieldNumber: 1)
    }
    if self.freeHeap != 0 {
      try visitor.visitSingularUInt32Field(value: self.freeHeap, fieldNumber: 2)
    }
    if let v = self._connect {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }
    if let v = self._masks {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D_Resp.State, rhs: D_Resp.State) -> Bool {
    if lhs.millis != rhs.millis {return false}
    if lhs.freeHeap != rhs.freeHeap {return false}
    if lhs._connect != rhs._connect {return false}
    if lhs._masks != rhs._masks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D_Resp.State.Connect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = D_Resp.State.protoMessageName + ".Connect"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ipV4Addres"),
    2: .same(proto: "mDNSName"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ipV4Addres) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.mDnsname) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ipV4Addres.isEmpty {
      try visitor.visitSingularStringField(value: self.ipV4Addres, fieldNumber: 1)
    }
    if !self.mDnsname.isEmpty {
      try visitor.visitSingularStringField(value: self.mDnsname, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D_Resp.State.Connect, rhs: D_Resp.State.Connect) -> Bool {
    if lhs.ipV4Addres != rhs.ipV4Addres {return false}
    if lhs.mDnsname != rhs.mDnsname {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D_Resp.State.Masks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = D_Resp.State.protoMessageName + ".Masks"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "persistent"),
    2: .same(proto: "standby"),
    3: .same(proto: "state"),
    4: .same(proto: "alarm"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.persistent) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.standby) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.state) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.alarm) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.persistent != 0 {
      try visitor.visitSingularUInt32Field(value: self.persistent, fieldNumber: 1)
    }
    if self.standby != 0 {
      try visitor.visitSingularUInt32Field(value: self.standby, fieldNumber: 2)
    }
    if self.state != 0 {
      try visitor.visitSingularUInt32Field(value: self.state, fieldNumber: 3)
    }
    if self.alarm != 0 {
      try visitor.visitSingularUInt32Field(value: self.alarm, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D_Resp.State.Masks, rhs: D_Resp.State.Masks) -> Bool {
    if lhs.persistent != rhs.persistent {return false}
    if lhs.standby != rhs.standby {return false}
    if lhs.state != rhs.state {return false}
    if lhs.alarm != rhs.alarm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D_Resp.Context: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = D_Resp.protoMessageName + ".Context"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "millis"),
    2: .same(proto: "busVoltage"),
    3: .same(proto: "coZeroV"),
    4: .same(proto: "coV"),
    5: .same(proto: "coPpm"),
    6: .same(proto: "tempCelsius"),
    7: .same(proto: "pressurePa"),
    8: .same(proto: "humidity"),
    9: .same(proto: "gasResistance"),
    10: .same(proto: "iaq"),
    11: .same(proto: "staticIaq"),
    12: .same(proto: "co2Equivalent"),
    13: .same(proto: "breathVocEquivalent"),
    14: .same(proto: "compGasValue"),
    15: .same(proto: "gasPercentage"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.millis) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.busVoltage) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.coZeroV) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.coV) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.coPpm) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.tempCelsius) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.pressurePa) }()
      case 8: try { try decoder.decodeSingularFloatField(value: &self.humidity) }()
      case 9: try { try decoder.decodeSingularFloatField(value: &self.gasResistance) }()
      case 10: try { try decoder.decodeSingularFloatField(value: &self.iaq) }()
      case 11: try { try decoder.decodeSingularFloatField(value: &self.staticIaq) }()
      case 12: try { try decoder.decodeSingularFloatField(value: &self.co2Equivalent) }()
      case 13: try { try decoder.decodeSingularFloatField(value: &self.breathVocEquivalent) }()
      case 14: try { try decoder.decodeSingularFloatField(value: &self.compGasValue) }()
      case 15: try { try decoder.decodeSingularFloatField(value: &self.gasPercentage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.millis != 0 {
      try visitor.visitSingularUInt32Field(value: self.millis, fieldNumber: 1)
    }
    if self.busVoltage != 0 {
      try visitor.visitSingularFloatField(value: self.busVoltage, fieldNumber: 2)
    }
    if self.coZeroV != 0 {
      try visitor.visitSingularFloatField(value: self.coZeroV, fieldNumber: 3)
    }
    if self.coV != 0 {
      try visitor.visitSingularFloatField(value: self.coV, fieldNumber: 4)
    }
    if self.coPpm != 0 {
      try visitor.visitSingularFloatField(value: self.coPpm, fieldNumber: 5)
    }
    if self.tempCelsius != 0 {
      try visitor.visitSingularFloatField(value: self.tempCelsius, fieldNumber: 6)
    }
    if self.pressurePa != 0 {
      try visitor.visitSingularFloatField(value: self.pressurePa, fieldNumber: 7)
    }
    if self.humidity != 0 {
      try visitor.visitSingularFloatField(value: self.humidity, fieldNumber: 8)
    }
    if self.gasResistance != 0 {
      try visitor.visitSingularFloatField(value: self.gasResistance, fieldNumber: 9)
    }
    if self.iaq != 0 {
      try visitor.visitSingularFloatField(value: self.iaq, fieldNumber: 10)
    }
    if self.staticIaq != 0 {
      try visitor.visitSingularFloatField(value: self.staticIaq, fieldNumber: 11)
    }
    if self.co2Equivalent != 0 {
      try visitor.visitSingularFloatField(value: self.co2Equivalent, fieldNumber: 12)
    }
    if self.breathVocEquivalent != 0 {
      try visitor.visitSingularFloatField(value: self.breathVocEquivalent, fieldNumber: 13)
    }
    if self.compGasValue != 0 {
      try visitor.visitSingularFloatField(value: self.compGasValue, fieldNumber: 14)
    }
    if self.gasPercentage != 0 {
      try visitor.visitSingularFloatField(value: self.gasPercentage, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D_Resp.Context, rhs: D_Resp.Context) -> Bool {
    if lhs.millis != rhs.millis {return false}
    if lhs.busVoltage != rhs.busVoltage {return false}
    if lhs.coZeroV != rhs.coZeroV {return false}
    if lhs.coV != rhs.coV {return false}
    if lhs.coPpm != rhs.coPpm {return false}
    if lhs.tempCelsius != rhs.tempCelsius {return false}
    if lhs.pressurePa != rhs.pressurePa {return false}
    if lhs.humidity != rhs.humidity {return false}
    if lhs.gasResistance != rhs.gasResistance {return false}
    if lhs.iaq != rhs.iaq {return false}
    if lhs.staticIaq != rhs.staticIaq {return false}
    if lhs.co2Equivalent != rhs.co2Equivalent {return false}
    if lhs.breathVocEquivalent != rhs.breathVocEquivalent {return false}
    if lhs.compGasValue != rhs.compGasValue {return false}
    if lhs.gasPercentage != rhs.gasPercentage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
