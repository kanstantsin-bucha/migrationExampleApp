// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: dAir.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Detecta_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sessionID: UInt32 = 0

  public var requestID: UInt32 = 0

  public var message: Detecta_Request.OneOf_Message? = nil

  public var setWifiState: Detecta_Request.SetWifiState {
    get {
      if case .setWifiState(let v)? = message {return v}
      return Detecta_Request.SetWifiState()
    }
    set {message = .setWifiState(newValue)}
  }

  public var setWifiCreds: Detecta_Request.SetWifiCreds {
    get {
      if case .setWifiCreds(let v)? = message {return v}
      return Detecta_Request.SetWifiCreds()
    }
    set {message = .setWifiCreds(newValue)}
  }

  public var getWifiNetworkInfo: Detecta_Request.GetWifiNetworkInfo {
    get {
      if case .getWifiNetworkInfo(let v)? = message {return v}
      return Detecta_Request.GetWifiNetworkInfo()
    }
    set {message = .getWifiNetworkInfo(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Message: Equatable {
    case setWifiState(Detecta_Request.SetWifiState)
    case setWifiCreds(Detecta_Request.SetWifiCreds)
    case getWifiNetworkInfo(Detecta_Request.GetWifiNetworkInfo)

  #if !swift(>=4.1)
    public static func ==(lhs: Detecta_Request.OneOf_Message, rhs: Detecta_Request.OneOf_Message) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.setWifiState, .setWifiState): return {
        guard case .setWifiState(let l) = lhs, case .setWifiState(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setWifiCreds, .setWifiCreds): return {
        guard case .setWifiCreds(let l) = lhs, case .setWifiCreds(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getWifiNetworkInfo, .getWifiNetworkInfo): return {
        guard case .getWifiNetworkInfo(let l) = lhs, case .getWifiNetworkInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct SetWifiState {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var isEnabled: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct SetWifiCreds {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var said: String = String()

    public var password: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct GetWifiNetworkInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Detecta_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sessionID: UInt32 = 0

  public var requestID: UInt32 = 0

  public var message: Detecta_Response.OneOf_Message? = nil

  public var getContextValues: Detecta_Response.GetContextValues {
    get {
      if case .getContextValues(let v)? = message {return v}
      return Detecta_Response.GetContextValues()
    }
    set {message = .getContextValues(newValue)}
  }

  public var setWifiState: Detecta_Response.SetWifiState {
    get {
      if case .setWifiState(let v)? = message {return v}
      return Detecta_Response.SetWifiState()
    }
    set {message = .setWifiState(newValue)}
  }

  public var setWifiCreds: Detecta_Response.SetWifiCreds {
    get {
      if case .setWifiCreds(let v)? = message {return v}
      return Detecta_Response.SetWifiCreds()
    }
    set {message = .setWifiCreds(newValue)}
  }

  public var getWifiNetworkInfo: Detecta_Response.GetWifiNetworkInfo {
    get {
      if case .getWifiNetworkInfo(let v)? = message {return v}
      return Detecta_Response.GetWifiNetworkInfo()
    }
    set {message = .getWifiNetworkInfo(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Message: Equatable {
    case getContextValues(Detecta_Response.GetContextValues)
    case setWifiState(Detecta_Response.SetWifiState)
    case setWifiCreds(Detecta_Response.SetWifiCreds)
    case getWifiNetworkInfo(Detecta_Response.GetWifiNetworkInfo)

  #if !swift(>=4.1)
    public static func ==(lhs: Detecta_Response.OneOf_Message, rhs: Detecta_Response.OneOf_Message) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.getContextValues, .getContextValues): return {
        guard case .getContextValues(let l) = lhs, case .getContextValues(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setWifiState, .setWifiState): return {
        guard case .setWifiState(let l) = lhs, case .setWifiState(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setWifiCreds, .setWifiCreds): return {
        guard case .setWifiCreds(let l) = lhs, case .setWifiCreds(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getWifiNetworkInfo, .getWifiNetworkInfo): return {
        guard case .getWifiNetworkInfo(let l) = lhs, case .getWifiNetworkInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum ProcessingStatus: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case unsupported // = 1
    case serviceError // = 2
    case generalError // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .unsupported
      case 2: self = .serviceError
      case 3: self = .generalError
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .unsupported: return 1
      case .serviceError: return 2
      case .generalError: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct GetContextValues {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var timestamp: UInt32 {
      get {return _storage._timestamp}
      set {_uniqueStorage()._timestamp = newValue}
    }

    public var freeHeap: UInt32 {
      get {return _storage._freeHeap}
      set {_uniqueStorage()._freeHeap = newValue}
    }

    public var deviceStateMask: UInt32 {
      get {return _storage._deviceStateMask}
      set {_uniqueStorage()._deviceStateMask = newValue}
    }

    public var alarmStateMask: UInt32 {
      get {return _storage._alarmStateMask}
      set {_uniqueStorage()._alarmStateMask = newValue}
    }

    public var powerSourceStateMask: UInt32 {
      get {return _storage._powerSourceStateMask}
      set {_uniqueStorage()._powerSourceStateMask = newValue}
    }

    public var busVoltage: Float {
      get {return _storage._busVoltage}
      set {_uniqueStorage()._busVoltage = newValue}
    }

    public var coZeroV: Float {
      get {return _storage._coZeroV}
      set {_uniqueStorage()._coZeroV = newValue}
    }

    public var coV: Float {
      get {return _storage._coV}
      set {_uniqueStorage()._coV = newValue}
    }

    public var coPpm: Float {
      get {return _storage._coPpm}
      set {_uniqueStorage()._coPpm = newValue}
    }

    public var tempCelsius: Float {
      get {return _storage._tempCelsius}
      set {_uniqueStorage()._tempCelsius = newValue}
    }

    public var pressurePa: Float {
      get {return _storage._pressurePa}
      set {_uniqueStorage()._pressurePa = newValue}
    }

    public var humidity: Float {
      get {return _storage._humidity}
      set {_uniqueStorage()._humidity = newValue}
    }

    public var gasResistance: Float {
      get {return _storage._gasResistance}
      set {_uniqueStorage()._gasResistance = newValue}
    }

    public var iaq: Float {
      get {return _storage._iaq}
      set {_uniqueStorage()._iaq = newValue}
    }

    public var staticIaq: Float {
      get {return _storage._staticIaq}
      set {_uniqueStorage()._staticIaq = newValue}
    }

    public var co2Equivalent: Float {
      get {return _storage._co2Equivalent}
      set {_uniqueStorage()._co2Equivalent = newValue}
    }

    public var breathVocEquivalent: Float {
      get {return _storage._breathVocEquivalent}
      set {_uniqueStorage()._breathVocEquivalent = newValue}
    }

    public var compGasValue: Float {
      get {return _storage._compGasValue}
      set {_uniqueStorage()._compGasValue = newValue}
    }

    public var gasPercentage: Float {
      get {return _storage._gasPercentage}
      set {_uniqueStorage()._gasPercentage = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct SetWifiState {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var status: Detecta_Response.ProcessingStatus = .ok

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct SetWifiCreds {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var status: Detecta_Response.ProcessingStatus = .ok

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct GetWifiNetworkInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var status: Detecta_Response.ProcessingStatus = .ok

    public var isConnected: Bool = false

    public var ipAddr: String = String()

    public var mDnsname: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Detecta_Response.ProcessingStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Detecta_Response.ProcessingStatus] = [
    .ok,
    .unsupported,
    .serviceError,
    .generalError,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "Detecta"

extension Detecta_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sessionId"),
    2: .same(proto: "requestId"),
    10: .same(proto: "setWifiState"),
    11: .same(proto: "setWifiCreds"),
    12: .same(proto: "getWifiNetworkInfo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.sessionID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.requestID) }()
      case 10: try {
        var v: Detecta_Request.SetWifiState?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .setWifiState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .setWifiState(v)}
      }()
      case 11: try {
        var v: Detecta_Request.SetWifiCreds?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .setWifiCreds(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .setWifiCreds(v)}
      }()
      case 12: try {
        var v: Detecta_Request.GetWifiNetworkInfo?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .getWifiNetworkInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .getWifiNetworkInfo(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sessionID != 0 {
      try visitor.visitSingularUInt32Field(value: self.sessionID, fieldNumber: 1)
    }
    if self.requestID != 0 {
      try visitor.visitSingularUInt32Field(value: self.requestID, fieldNumber: 2)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.message {
    case .setWifiState?: try {
      guard case .setWifiState(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .setWifiCreds?: try {
      guard case .setWifiCreds(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .getWifiNetworkInfo?: try {
      guard case .getWifiNetworkInfo(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Detecta_Request, rhs: Detecta_Request) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Detecta_Request.SetWifiState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Detecta_Request.protoMessageName + ".SetWifiState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isEnabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isEnabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isEnabled != false {
      try visitor.visitSingularBoolField(value: self.isEnabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Detecta_Request.SetWifiState, rhs: Detecta_Request.SetWifiState) -> Bool {
    if lhs.isEnabled != rhs.isEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Detecta_Request.SetWifiCreds: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Detecta_Request.protoMessageName + ".SetWifiCreds"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "said"),
    2: .same(proto: "password"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.said) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.said.isEmpty {
      try visitor.visitSingularStringField(value: self.said, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Detecta_Request.SetWifiCreds, rhs: Detecta_Request.SetWifiCreds) -> Bool {
    if lhs.said != rhs.said {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Detecta_Request.GetWifiNetworkInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Detecta_Request.protoMessageName + ".GetWifiNetworkInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Detecta_Request.GetWifiNetworkInfo, rhs: Detecta_Request.GetWifiNetworkInfo) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Detecta_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sessionId"),
    2: .same(proto: "requestId"),
    10: .same(proto: "getContextValues"),
    11: .same(proto: "setWifiState"),
    12: .same(proto: "setWifiCreds"),
    13: .same(proto: "getWifiNetworkInfo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.sessionID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.requestID) }()
      case 10: try {
        var v: Detecta_Response.GetContextValues?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .getContextValues(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .getContextValues(v)}
      }()
      case 11: try {
        var v: Detecta_Response.SetWifiState?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .setWifiState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .setWifiState(v)}
      }()
      case 12: try {
        var v: Detecta_Response.SetWifiCreds?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .setWifiCreds(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .setWifiCreds(v)}
      }()
      case 13: try {
        var v: Detecta_Response.GetWifiNetworkInfo?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .getWifiNetworkInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .getWifiNetworkInfo(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sessionID != 0 {
      try visitor.visitSingularUInt32Field(value: self.sessionID, fieldNumber: 1)
    }
    if self.requestID != 0 {
      try visitor.visitSingularUInt32Field(value: self.requestID, fieldNumber: 2)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.message {
    case .getContextValues?: try {
      guard case .getContextValues(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .setWifiState?: try {
      guard case .setWifiState(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .setWifiCreds?: try {
      guard case .setWifiCreds(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .getWifiNetworkInfo?: try {
      guard case .getWifiNetworkInfo(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Detecta_Response, rhs: Detecta_Response) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Detecta_Response.ProcessingStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "Unsupported"),
    2: .same(proto: "ServiceError"),
    3: .same(proto: "GeneralError"),
  ]
}

extension Detecta_Response.GetContextValues: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Detecta_Response.protoMessageName + ".GetContextValues"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "freeHeap"),
    3: .same(proto: "deviceStateMask"),
    4: .same(proto: "alarmStateMask"),
    5: .same(proto: "powerSourceStateMask"),
    6: .same(proto: "busVoltage"),
    7: .same(proto: "coZeroV"),
    8: .same(proto: "coV"),
    9: .same(proto: "coPpm"),
    10: .same(proto: "tempCelsius"),
    11: .same(proto: "pressurePa"),
    12: .same(proto: "humidity"),
    13: .same(proto: "gasResistance"),
    14: .same(proto: "iaq"),
    15: .same(proto: "staticIaq"),
    16: .same(proto: "co2Equivalent"),
    17: .same(proto: "breathVocEquivalent"),
    18: .same(proto: "compGasValue"),
    19: .same(proto: "gasPercentage"),
  ]

  fileprivate class _StorageClass {
    var _timestamp: UInt32 = 0
    var _freeHeap: UInt32 = 0
    var _deviceStateMask: UInt32 = 0
    var _alarmStateMask: UInt32 = 0
    var _powerSourceStateMask: UInt32 = 0
    var _busVoltage: Float = 0
    var _coZeroV: Float = 0
    var _coV: Float = 0
    var _coPpm: Float = 0
    var _tempCelsius: Float = 0
    var _pressurePa: Float = 0
    var _humidity: Float = 0
    var _gasResistance: Float = 0
    var _iaq: Float = 0
    var _staticIaq: Float = 0
    var _co2Equivalent: Float = 0
    var _breathVocEquivalent: Float = 0
    var _compGasValue: Float = 0
    var _gasPercentage: Float = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _timestamp = source._timestamp
      _freeHeap = source._freeHeap
      _deviceStateMask = source._deviceStateMask
      _alarmStateMask = source._alarmStateMask
      _powerSourceStateMask = source._powerSourceStateMask
      _busVoltage = source._busVoltage
      _coZeroV = source._coZeroV
      _coV = source._coV
      _coPpm = source._coPpm
      _tempCelsius = source._tempCelsius
      _pressurePa = source._pressurePa
      _humidity = source._humidity
      _gasResistance = source._gasResistance
      _iaq = source._iaq
      _staticIaq = source._staticIaq
      _co2Equivalent = source._co2Equivalent
      _breathVocEquivalent = source._breathVocEquivalent
      _compGasValue = source._compGasValue
      _gasPercentage = source._gasPercentage
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._timestamp) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._freeHeap) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._deviceStateMask) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._alarmStateMask) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._powerSourceStateMask) }()
        case 6: try { try decoder.decodeSingularFloatField(value: &_storage._busVoltage) }()
        case 7: try { try decoder.decodeSingularFloatField(value: &_storage._coZeroV) }()
        case 8: try { try decoder.decodeSingularFloatField(value: &_storage._coV) }()
        case 9: try { try decoder.decodeSingularFloatField(value: &_storage._coPpm) }()
        case 10: try { try decoder.decodeSingularFloatField(value: &_storage._tempCelsius) }()
        case 11: try { try decoder.decodeSingularFloatField(value: &_storage._pressurePa) }()
        case 12: try { try decoder.decodeSingularFloatField(value: &_storage._humidity) }()
        case 13: try { try decoder.decodeSingularFloatField(value: &_storage._gasResistance) }()
        case 14: try { try decoder.decodeSingularFloatField(value: &_storage._iaq) }()
        case 15: try { try decoder.decodeSingularFloatField(value: &_storage._staticIaq) }()
        case 16: try { try decoder.decodeSingularFloatField(value: &_storage._co2Equivalent) }()
        case 17: try { try decoder.decodeSingularFloatField(value: &_storage._breathVocEquivalent) }()
        case 18: try { try decoder.decodeSingularFloatField(value: &_storage._compGasValue) }()
        case 19: try { try decoder.decodeSingularFloatField(value: &_storage._gasPercentage) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._timestamp != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._timestamp, fieldNumber: 1)
      }
      if _storage._freeHeap != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._freeHeap, fieldNumber: 2)
      }
      if _storage._deviceStateMask != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._deviceStateMask, fieldNumber: 3)
      }
      if _storage._alarmStateMask != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._alarmStateMask, fieldNumber: 4)
      }
      if _storage._powerSourceStateMask != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._powerSourceStateMask, fieldNumber: 5)
      }
      if _storage._busVoltage != 0 {
        try visitor.visitSingularFloatField(value: _storage._busVoltage, fieldNumber: 6)
      }
      if _storage._coZeroV != 0 {
        try visitor.visitSingularFloatField(value: _storage._coZeroV, fieldNumber: 7)
      }
      if _storage._coV != 0 {
        try visitor.visitSingularFloatField(value: _storage._coV, fieldNumber: 8)
      }
      if _storage._coPpm != 0 {
        try visitor.visitSingularFloatField(value: _storage._coPpm, fieldNumber: 9)
      }
      if _storage._tempCelsius != 0 {
        try visitor.visitSingularFloatField(value: _storage._tempCelsius, fieldNumber: 10)
      }
      if _storage._pressurePa != 0 {
        try visitor.visitSingularFloatField(value: _storage._pressurePa, fieldNumber: 11)
      }
      if _storage._humidity != 0 {
        try visitor.visitSingularFloatField(value: _storage._humidity, fieldNumber: 12)
      }
      if _storage._gasResistance != 0 {
        try visitor.visitSingularFloatField(value: _storage._gasResistance, fieldNumber: 13)
      }
      if _storage._iaq != 0 {
        try visitor.visitSingularFloatField(value: _storage._iaq, fieldNumber: 14)
      }
      if _storage._staticIaq != 0 {
        try visitor.visitSingularFloatField(value: _storage._staticIaq, fieldNumber: 15)
      }
      if _storage._co2Equivalent != 0 {
        try visitor.visitSingularFloatField(value: _storage._co2Equivalent, fieldNumber: 16)
      }
      if _storage._breathVocEquivalent != 0 {
        try visitor.visitSingularFloatField(value: _storage._breathVocEquivalent, fieldNumber: 17)
      }
      if _storage._compGasValue != 0 {
        try visitor.visitSingularFloatField(value: _storage._compGasValue, fieldNumber: 18)
      }
      if _storage._gasPercentage != 0 {
        try visitor.visitSingularFloatField(value: _storage._gasPercentage, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Detecta_Response.GetContextValues, rhs: Detecta_Response.GetContextValues) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._freeHeap != rhs_storage._freeHeap {return false}
        if _storage._deviceStateMask != rhs_storage._deviceStateMask {return false}
        if _storage._alarmStateMask != rhs_storage._alarmStateMask {return false}
        if _storage._powerSourceStateMask != rhs_storage._powerSourceStateMask {return false}
        if _storage._busVoltage != rhs_storage._busVoltage {return false}
        if _storage._coZeroV != rhs_storage._coZeroV {return false}
        if _storage._coV != rhs_storage._coV {return false}
        if _storage._coPpm != rhs_storage._coPpm {return false}
        if _storage._tempCelsius != rhs_storage._tempCelsius {return false}
        if _storage._pressurePa != rhs_storage._pressurePa {return false}
        if _storage._humidity != rhs_storage._humidity {return false}
        if _storage._gasResistance != rhs_storage._gasResistance {return false}
        if _storage._iaq != rhs_storage._iaq {return false}
        if _storage._staticIaq != rhs_storage._staticIaq {return false}
        if _storage._co2Equivalent != rhs_storage._co2Equivalent {return false}
        if _storage._breathVocEquivalent != rhs_storage._breathVocEquivalent {return false}
        if _storage._compGasValue != rhs_storage._compGasValue {return false}
        if _storage._gasPercentage != rhs_storage._gasPercentage {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Detecta_Response.SetWifiState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Detecta_Response.protoMessageName + ".SetWifiState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .ok {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Detecta_Response.SetWifiState, rhs: Detecta_Response.SetWifiState) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Detecta_Response.SetWifiCreds: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Detecta_Response.protoMessageName + ".SetWifiCreds"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .ok {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Detecta_Response.SetWifiCreds, rhs: Detecta_Response.SetWifiCreds) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Detecta_Response.GetWifiNetworkInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Detecta_Response.protoMessageName + ".GetWifiNetworkInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "isConnected"),
    3: .same(proto: "ipAddr"),
    4: .same(proto: "mDNSName"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isConnected) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ipAddr) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.mDnsname) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .ok {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if self.isConnected != false {
      try visitor.visitSingularBoolField(value: self.isConnected, fieldNumber: 2)
    }
    if !self.ipAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.ipAddr, fieldNumber: 3)
    }
    if !self.mDnsname.isEmpty {
      try visitor.visitSingularStringField(value: self.mDnsname, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Detecta_Response.GetWifiNetworkInfo, rhs: Detecta_Response.GetWifiNetworkInfo) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.isConnected != rhs.isConnected {return false}
    if lhs.ipAddr != rhs.ipAddr {return false}
    if lhs.mDnsname != rhs.mDnsname {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
